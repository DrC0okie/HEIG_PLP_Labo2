-- Test suite to validate basic and edge cases of our Map
-- To run it, install HUnit with "cabal install --lib HUnit" and run 'ghc --run MapTests.hs' inside "src"

import Control.Exception (ErrorCall (ErrorCall), SomeException (SomeException), evaluate, try)
import Control.Monad
import Data.Char (toUpper)
import Data.Either (isLeft, isRight)
import Data.List (isInfixOf)
import Map
import Test.HUnit

-- Simple map with 5 elements for easier testing: {'v' -> 1, 'w' -> 2, 'x' -> 3, 'y' -> 4, 'z' -> 5}
simpleMap :: Map
simpleMap = insert 'v' 1 $ insert 'w' 2 $ insert 'x' 3 $ insert 'y' 4 $ insert 'z' 5 empty

-- Shortcut for shorter assertions, instead of "TestCase (assertEqual ...)" just "eq ..."
eq :: (Eq a, Show a) => String -> a -> a -> Test
eq title expected given = TestCase (assertEqual title expected given)

-- doesFail makes sure the given expression will fail via the error function
-- and contains the expectedError inside the given error (it may be equal)
doesFail :: String -> Map -> String -> Test
doesFail title expression expectedError =
    TestCase
        ( do
            -- We use ErrorCall (instead of SomeException) to only catch
            -- exception generated by the "error" function
            result <- try (evaluate expression) :: IO (Either ErrorCall Map)
            -- Assert this is an exception, by failing
            when
                (isRight result)
                ( do
                    let Right map = result
                    assertFailure (title ++ ": Should gave error '" ++ expectedError ++ "' but returned map " ++ show map ++ ".")
                )

            -- Checking the error message content
            let Left (ErrorCall actualError) = result
            unless
                (isInfixOf expectedError actualError)
                (assertFailure ("Given error '" ++ actualError ++ "' failed to contains '" ++ expectedError ++ "'"))
        )

-- Our test suites for all Map functions
tests :: Test
tests =
    TestList
        [ eq "empty map" Nothing (empty 'x')
        , eq "singleton of x=2" (Just 2) (singleton 'x' 2 'x')
        , eq "singleton of K=2341230" (Just 2341230) (singleton 'K' 2341230 'K')
        , eq "singleton of x=2 only contains x" Nothing (singleton 'x' 2 'y')
        , eq "insert in empty works" (Just 2) (insert 'x' 2 empty 'x')
        , eq "insert in singleton works" (Just 2) (insert 'x' 2 (singleton 'y' 5) 'x')
        , eq "insert in singleton doesn't remove existing value" (Just 5) (insert 'x' 2 (singleton 'y' 5) 'y')
        , eq "insert existing key replaces it" (Just 2) (insert 'x' 2 simpleMap 'x')
        , eq "find doesn't find non existant values" Nothing (find 'x' empty)
        , eq "find doesn't find non existant values" Nothing (find 'z' (singleton 'x' 2))
        , eq "findOrDefault works" 5 (findOrDefault 'z' 10 (insert 'z' 5 (singleton 'x' 2)))
        , eq "findOrDefault works" 10 (findOrDefault 'y' 10 (insert 'z' 5 (singleton 'x' 2)))
        , eq "delete on empty map works" Nothing (delete 'z' empty 'x')
        , eq "delete non existant value works" Nothing (delete 'z' (singleton 'x' 2) 'z')
        , eq "delete non existant value works" (Just 2) (delete 'z' (singleton 'x' 2) 'x')
        , eq "delete existing value actually deletes it" Nothing (delete 'z' (singleton 'z' 50) 'z')
        , eq "update non existant value does nothing" (Just 5) (update 'l' (+ 25) simpleMap 'z')
        , eq "update existant value works" (Just 30) (update 'z' (+ 25) simpleMap 'z')
        , eq "update existant value doesn't change other values" (Just 3) (update 'z' (+ 25) simpleMap 'x')
        , eq "member works" False (member 'x' empty)
        , eq "member works" True (member 'x' simpleMap)
        , eq "member works" False (member 'u' simpleMap)
        , eq "size works" 5 (size simpleMap)
        , eq "size works" 0 (size empty)
        , eq "size works" 1 (size (singleton 'x' 3))
        , eq "isEmpty works" True (isEmpty empty)
        , eq "isEmpty works" False (isEmpty simpleMap)
        , eq "keys works" "vwxyz" (keys simpleMap)
        , eq "keys works" "x" (keys (singleton 'x' 3))
        , eq "keys works" "" (keys empty)
        , eq "values works" [1, 2, 3, 4, 5] (values simpleMap)
        , eq "values works" [3] (values (singleton 'x' 3))
        , eq "values works" [] (values empty)
        , eq "keysWithValue finds a single key" ['x'] (keysWithValue 3 (insert 'x' 3 empty))
        , eq "keysWithValue finds multiple keys" ['x', 'y'] (keysWithValue 3 (insert 'x' 3 (insert 'y' 3 empty)))
        , eq "keysWithValue returns empty list for nonexistent value" [] (keysWithValue 5 (insert 'x' 3 (insert 'y' 3 empty)))
        , eq "keysWithValue returns empty list for empty map" [] (keysWithValue 3 empty)
        , eq "keysWithValue works with singleton map" ['x'] (keysWithValue 3 (singleton 'x' 3))
        , eq "keysWithValue returns empty for value with no association" [] (keysWithValue 99 (insert 'x' 3 (insert 'y' 10 (insert 'z' 20 empty))))
        , eq "union works with empty map" (Just 3) (union simpleMap empty 'x')
        , eq "union works with singleton" (Just 100) (union simpleMap (singleton 'k' 100) 'k')
        , eq "union works with singleton" (Just 1) (union simpleMap (singleton 'k' 100) 'v')
        , eq "union works with empty map first" Nothing (union empty (singleton 'k' 100) 'v')
        , eq "union works with empty map first" (Just 100) (union empty (singleton 'k' 100) 'k')
        , eq "union works with with same elements" (Just 3) (union simpleMap (singleton 'x' 15) 'x')
        , eq "intersection works with empty map" "{}" (show (intersection empty simpleMap))
        , eq "intersection with 2 maps - empty" "{}" (show (intersection simpleMap (singleton 'u' 90)))
        , eq "intersection with matching value" "{'x' -> 3}" (show (intersection simpleMap (singleton 'x' 3)))
        , eq "intersection with partially matching values" "{'x' -> 3}" (show (intersection simpleMap (insert 'y' 10 (singleton 'x' 3))))
        , eq "intersection with 2 maps with different values" "{}" (show (intersection simpleMap (insert 'y' 10 (singleton 'x' 90))))
        , eq "difference works on empty map" Nothing (difference empty simpleMap 'x')
        , eq "difference works with removed empty map" (Just 3) (difference simpleMap empty 'x')
        , eq "difference works on empty map" (Just 3) (difference simpleMap (singleton 'z' 3) 'x')
        , eq "difference with same key and value" Nothing (difference simpleMap (singleton 'z' 5) 'z')
        , eq "difference with same key but different value" (Just 5) (difference simpleMap (singleton 'z' 7) 'z')
        , eq "mapValues works" [2, 4, 6, 8, 10] (values (mapValues (* 2) simpleMap))
        , eq "mapValues doesn't change keys" "vwxyz" (keys (mapValues (* 2) simpleMap))
        , eq "mapValues works" [-1, 0, 1, 2, 3] (values (mapValues (\x -> x - 2) simpleMap))
        , eq "mapKeys works" "VWXYZ" (keys (mapKeys toUpper simpleMap))
        , eq "mapKeys with toUpper preserves values" [1, 2, 3, 4, 5] (values (mapKeys toUpper simpleMap))
        , eq "mapKeys original key returns Nothing" Nothing (mapKeys toUpper simpleMap 'v')
        , eq "filterMap works" [2, 4] (values (filterMap (\k v -> even v) simpleMap))
        , eq "filterMap works" [1, 2, 3] (values (filterMap (\k v -> k < 'y') simpleMap))
        , eq "anyEntry works" True (anyEntry (\k v -> v == 3) simpleMap)
        , eq "anyEntry works" False (anyEntry (\k v -> v > 10) simpleMap)
        , eq "allEntries works" False (allEntries (\k v -> v == 3) simpleMap)
        , eq "allEntries works" True (allEntries (\k v -> v < 10) simpleMap)
        , TestCase
            ( do
                let (m1, m2) = partition (\k v -> v < 10) simpleMap
                assertEqual "partition works on first map" [1, 2, 3, 4, 5] (values m1)
                assertEqual "partition works on second map" [] (values m2)
            )
        , TestCase
            ( do
                let (m1, m2) = partition (\k v -> v > 3) simpleMap
                assertEqual "partition works on first map" [4, 5] (values m1)
                assertEqual "partition works on second map" [1, 2, 3] (values m2)
            )
        , TestCase
            ( do
                let (m1, m2) = split 'x' simpleMap
                assertEqual "split works on first map" [1, 2, 3] (values m1)
                assertEqual "split works on second map" [4, 5] (values m2)
            )
        , TestCase
            ( do
                let (m1, m2) = split 'v' simpleMap
                assertEqual "split works on first map" [1] (values m1)
                assertEqual "split works on second map" [2, 3, 4, 5] (values m2)
            )
        , TestCase
            ( do
                let (m1, m2) = split 'a' simpleMap
                assertEqual "Splitting the map to non-existing key (m1)" [] (values m1)
                assertEqual "Splitting the map to non-existing key (m2)" [1, 2, 3, 4, 5] (values m2)
            )
        , TestCase
            ( do
                let (m1, m2) = split 'z' simpleMap
                assertEqual "Splitting the map to the last key of the map (m1)" [1, 2, 3, 4, 5] (values m1)
                assertEqual "Splitting the map to the last key of the map (m2)" [] (values m2)
            )
        , eq "findMax works" (Just 5) (findMax simpleMap)
        , eq "findMax works" Nothing (findMax empty)
        , eq "findMin works" (Just 1) (findMin simpleMap)
        , eq "findMin works" Nothing (findMin empty)
        , TestCase
            ( do
                let m = fromList [('x', 3), ('y', 10), ('z', 20)]
                assertEqual "fromList works" (Just 3) (m 'x')
                assertEqual "fromList works" (Just 10) (m 'y')
                assertEqual "fromList works" (Just 20) (m 'z')
                assertEqual "fromList works" Nothing (m '2')
            )
        , eq "toList works" [('x', 3), ('y', 10), ('z', 20)] (toList (insert 'x' 3 (insert 'y' 10 (insert 'z' 20 empty))))
        , eq "toList works" [('x', 3)] (toList (singleton 'x' 3))
        , eq "toList works" [] (toList empty)
        , TestCase
            ( do
                let m = fromString "{'x' -> 3, 'y' -> 10, 'z' -> 20}"
                assertEqual "fromString works" (Just 3) (m 'x')
                assertEqual "fromString works" (Just 10) (m 'y')
                assertEqual "fromString works" (Just 20) (m 'z')
                assertEqual "fromString works" Nothing (m '3')
            )
        , eq "parses simple map correctly" "{'x' -> 3, 'y' -> 5}" (show (fromString "{'x' -> 3, 'y' -> 5}"))
        , eq "parses empty map" "{}" (show (fromString "{}"))
        , eq "parses map with multiple-digit values" "{'x' -> 100, 'y' -> 200}" (show (fromString "{'x' -> 100, 'y' -> 200}"))
        , -- Invalid format tests
          eq "fromString on empty string" empty (fromString "{}")
        , eq "Eq is implemented" simpleMap simpleMap
        , eq "show is implemented" "{'v' -> 1, 'w' -> 2, 'x' -> 3, 'y' -> 4, 'z' -> 5}" (show simpleMap)
        , doesFail "throws error on empty string" (fromString "") "cannot parse empty string"
        , doesFail "throws error on unfinished map " (fromString "{'}") "Invalid format"
        , doesFail "throws error on blabla" (fromString "blabla") "Invalid format"
        , doesFail "throws error on extra spaces around braces" (fromString " {'x' -> 3, 'y' -> 5}     ") "Invalid format"
        , doesFail "throws error on missing braces" (fromString "'x' -> 3, 'y' -> 5") "Invalid format"
        , -- Those tests were disabled because they fail even though the expression correctly fails in GHCI
          -- with an errors so they should pass... That's maybe a bug in HUnit ?
          -- doesFail "throws error on double comma+space sequence" (fromString "{'x' -> 3, , 'y' -> 6}") "Invalid format"
          -- doesFail "throws error on double comma+space sequence" (fromString "{'x' -> 3,   , 'y' -> 6}") "Invalid format"
          -- doesFail "throws error on missing element" (fromString "{'x' -> 3,}")
          -- doesFail "throws error on double commas" (fromString "{'x' -> 3,, 'y' -> 5}")
          -- doesFail "throws error on double end braces" (fromString "{'x' -> 3, 'y' -> 5}}")
          -- doesFail "throws error on extra space before comma" (fromString "{'x' -> 3 , 'y' -> 5}")
          doesFail "throws error on double arrows" (fromString "{'x' ->-> 4, 'y' -> 11}") "Invalid format"
        , doesFail "throws error on double spaces" (fromString "{'x'  -> 5, 'y' -> 8}") "Invalid format"
        , doesFail "throws error on double single quote" (fromString "{''x' -> 6 , 'y' -> 6}") "Invalid format"
        , doesFail "throws error on missing separator" (fromString "{x 7, y 7}") "Invalid format"
        , doesFail "throws error on missing key before '->'" (fromString "{ -> 9, 'y' -> 11}") "Invalid format"
        , doesFail "throws error on incomplete key-value pair" (fromString "{'x' ->, 'y' -> 12}") "Invalid format"
        ]

main :: IO Counts
main = runTestTT tests
